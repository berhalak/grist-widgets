// THIS FILE WAS AUTOGENERATED BY ./generate.js
const definition = `
// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../../../../../grist-widget/inspect/grain-rpc
//   ../../../../../grist-widget/inspect/app/plugin/DocApiTypes
//   ../../../../../grist-widget/inspect/ts-interface-checker

declare module 'grist' {
    import { ColumnsToMap, CustomSectionAPI, InteractionOptions, InteractionOptionsRequest, WidgetColumnMap } from 'grist/CustomSectionAPI';
    import { GristAPI, GristDocAPI, GristView } from 'grist/GristAPI';
    import { RowRecord } from 'grist/GristData';
    import { RenderOptions } from 'grist/RenderOptions';
    import { TableOperations } from 'grist/TableOperations';
    import { WidgetAPI } from 'grist/WidgetAPI';
    export * from 'grist/TypeCheckers';
    export * from 'grist/FileParserAPI';
    export * from 'grist/GristAPI';
    export * from 'grist/GristData';
    export * from 'grist/GristTable';
    export * from 'grist/ImportSourceAPI';
    export * from 'grist/StorageAPI';
    export * from 'grist/RenderOptions';
    export * from 'grist/WidgetAPI';
    export * from 'grist/CustomSectionAPI';
    import { Rpc } from 'grain-rpc';
    export const rpc: Rpc;
    export const api: GristAPI;
    export const coreDocApi: GristDocAPI;
    /**
        * Interface for the records backing a custom widget.
        */
    export const viewApi: GristView;
    /**
        * Interface for the state of a custom widget.
        */
    export const widgetApi: WidgetAPI;
    /**
        * Interface for the mapping of a custom widget.
        */
    export const sectionApi: CustomSectionAPI;
    /**
        * Shortcut for [[GristView.allowSelectBy]].
        */
    export const allowSelectBy: () => Promise<void>;
    /**
        * Shortcut for [[GristView.setSelectedRows]].
        */
    export const setSelectedRows: (rowIds: number[]) => Promise<void>;
    /**
        * Fetches data backing the widget as for [[GristView.fetchSelectedTable]],
        * but decoding data by default, replacing e.g. ['D', timestamp] with
        * a moment date. Option 'keepEncoded' skips the decoding step.
        */
    export function fetchSelectedTable(options?: {
            keepEncoded?: boolean;
    }): Promise<any>;
    /**
        * Fetches current selected record as for [[GristView.fetchSelectedRecord]],
        * but decoding data by default, replacing e.g. ['D', timestamp] with
        * a moment date. Option 'keepEncoded' skips the decoding step.
        */
    export function fetchSelectedRecord(rowId: number, options?: {
            keepEncoded?: boolean;
    }): Promise<any>;
    /**
        * A collection of methods for fetching document data. The
        * fetchSelectedTable and fetchSelectedRecord methods are
        * overridden to decode data by default.
        */
    export const docApi: GristDocAPI & GristView;
    export const on: (event: string | symbol, listener: (...args: any[]) => void) => Rpc;
    /**
        * Shortcut for [[WidgetAPI.getOption]]
        */
    export const getOption: (key: string) => Promise<any>;
    /**
        * Shortcut for [[WidgetAPI.setOption]]
        */
    export const setOption: (key: string, value: any) => Promise<void>;
    /**
        * Shortcut for [[WidgetAPI.setOptions]]
        */
    export const setOptions: (options: {
            [key: string]: any;
    }) => Promise<void>;
    /**
        * Shortcut for [[WidgetAPI.getOptions]]
        */
    export const getOptions: () => Promise<object | null>;
    /**
        * Shortcut for [[WidgetAPI.clearOptions]]
        */
    export const clearOptions: () => Promise<void>;
    /**
        * Get access to a table in the document. If no tableId specified, this
        * will use the current selected table (for custom widgets).
        * If a table does not exist, there will be no error until an operation
        * on the table is attempted.
        */
    export function getTable(tableId?: string): TableOperations;
    /**
        * Get the current selected table (for custom widgets).
        */
    export const selectedTable: TableOperations;
    export function getSelectedTableId(): Promise<string>;
    export function getSelectedTableIdSync(): string | undefined;
    /**
        * Renames columns in the result using columns mapping configuration passed in ready method.
        * Returns null if not all required columns were mapped or not widget doesn't support
        * custom column mapping.
        */
    export function mapColumnNames(data: any, options?: {
            columns?: ColumnsToMap;
            mappings?: WidgetColumnMap | null;
            reverse?: boolean;
    }): any;
    /**
        * Offer a convenient way to map data with renamed columns back into the
        * form used in the original table. This is useful for making edits to the
        * original table in a widget with column mappings. As for mapColumnNames(),
        * we don't attempt to do these transformations automatically.
        */
    export function mapColumnNamesBack(data: any, options?: {
            columns?: ColumnsToMap;
            mappings?: WidgetColumnMap | null;
    }): any;
    /**
        * For custom widgets, add a handler that will be called whenever the
        * row with the cursor changes - either by switching to a different row, or
        * by some value within the row potentially changing.  Handler may
        * in the future be called with null if the cursor moves away from
        * any row.
        */
    export function onRecord(callback: (data: RowRecord | null, mappings: WidgetColumnMap | null) => unknown): void;
    /**
        * For custom widgets, add a handler that will be called whenever the
        * new (blank) row is selected.
        */
    export function onNewRecord(callback: (mappings: WidgetColumnMap | null) => unknown): void;
    /**
        * For custom widgets, add a handler that will be called whenever the
        * selected records change.  Handler will be called with a list of records.
        */
    export function onRecords(callback: (data: RowRecord[], mappings: WidgetColumnMap | null) => unknown): void;
    /**
        * For custom widgets, add a handler that will be called whenever the
        * widget options change (and on initial ready message). Handler will be
        * called with an object containing saved json options, or null if no options were saved.
        * The second parameter has information about the widgets relationship with
        * the document that contains it.
        */
    export function onOptions(callback: (options: any, settings: InteractionOptions) => unknown): void;
    /**
        * Calling 'addImporter(...)' adds a safeBrowser importer. It is a short-hand for forwarding calls
        * to an 'ImportSourceAPI' implementation registered in the file at 'path'. It takes care of
        * creating the stub, registering an implementation that renders the file, forward the call and
        * dispose the view properly. If 'mode' is ''inline'' embeds the view in the import modal, otherwise
        * renders fullscreen.
        *
        * Notes: it assumes that file at 'path' registers an 'ImportSourceAPI' implementation under
        * 'name'. Calling 'addImporter(...)' from another component than a 'safeBrowser' component is not
        * currently supported.
        *
        * @internal
        */
    export function addImporter(name: string, path: string, mode: 'fullscreen' | 'inline', options?: RenderOptions): Promise<void>;
    /**
        * Options when initializing connection to Grist.
        */
    export interface ReadyPayload extends Omit<InteractionOptionsRequest, "hasCustomOptions"> {
            /**
                * Handler that will be called by Grist to open additional configuration panel inside the Custom Widget.
                */
            onEditOptions: () => unknown;
    }
    /**
        * Declare that a component is prepared to receive messages from the outside world.
        * Grist will not attempt to communicate with it until this method is called.
        */
    export function ready(settings?: ReadyPayload): void;
}

declare module 'grist/CustomSectionAPI' {
    /**
        * API definitions for CustomSection plugins.
        */
    export interface ColumnToMap {
            /**
                * Column name that Widget expects. Must be a valid JSON property name.
                */
            name: string;
            /**
                * Title or short description of a column (used as a label in section mapping).
                */
            title?: string | null;
            /**
                * Column type, by default ANY.
                */
            type?: string;
            /**
                * Mark column as optional all columns are required by default.
                */
            optional?: boolean;
            /**
                * Allow multiple column assignment, the result will be list of mapped table column names.
                */
            allowMultiple?: boolean;
    }
    export type ColumnsToMap = (string | ColumnToMap)[];
    /**
        * Initial message sent by the CustomWidget with initial requirements.
        */
    export interface InteractionOptionsRequest {
            /**
                * Required access level. If it wasn't granted already, Grist will prompt user to change the current access
                * level.
                */
            requiredAccess?: string;
            /**
                * Instructs Grist to show additional menu options that will trigger onEditOptions callback, that Widget
                * can use to show custom options screen.
                */
            hasCustomOptions?: boolean;
            /**
                * Tells Grist what columns Custom Widget expects and allows user to map between existing column names
                * and those requested by Custom Widget.
                */
            columns?: ColumnsToMap;
    }
    /**
        * Widget configuration set and approved by Grist, sent as part of ready message.
        */
    export interface InteractionOptions {
            /**
                * Granted access level.
                */
            accessLevel: string;
    }
    /**
        * Current columns mapping between viewFields in section and Custom widget.
        */
    export interface WidgetColumnMap {
            [key: string]: string | string[] | null;
    }
    export interface CustomSectionAPI {
            /**
                * Initial request from a Custom Widget that wants to declare its requirements.
                */
            configure(customOptions: InteractionOptionsRequest): Promise<void>;
            /**
                * Returns current widget configuration (if requested through configuration method).
                */
            mappings(): Promise<WidgetColumnMap | null>;
    }
}

declare module 'grist/GristAPI' {
    /**
        * This file defines the interface for the grist api exposed to SafeBrowser plugins. Grist supports
        * various ways to require it to cover various scenarios. If writing the main safeBrowser module
        * (the one referenced by the components.safeBrowser key of the manifest) use
        * 'self.importScript('grist');', if writing a view include the script in the html '<script src="grist"></script>'
        *
        *
        * Example usage (let's assume that Grist let's plugin contributes to a Foo API defined as follow ):
        *
        * interface Foo {
        *   foo(name: string): Promise<string>;
        * }
        *
        * > main.ts:
        * class MyFoo {
        *   public foo(name: string): Promise<string> {
        *     return new Promise<string>( async resolve => {
        *       grist.rpc.onMessage( e => {
        *         resolve(e.data + name);
        *       });
        *       grist.ready();
        *       await grist.api.render('view1.html', 'fullscreen');
        *     });
        *   }
        * }
        * grist.rpc.registerImpl<Foo>('grist', new MyFoo()); // can add 3rd arg with type information
        *
        * > view1.html includes:
        * grist.api.render('static/view2.html', 'fullscreen').then( view => {
        *   grist.rpc.onMessage(e => grist.rpc.postMessageForward("main.ts", e.data));
        * });
        *
        * > view2.html includes:
        * grist.rpc.postMessage('view1.html', 'foo ');
        *
        */
    import { RenderOptions, RenderTarget } from 'grist/RenderOptions';
    export type ComponentKind = "safeBrowser" | "safePython" | "unsafeNode";
    export const RPC_GRISTAPI_INTERFACE = "_grist_api";
    export interface GristAPI {
            /**
                * Render the file at 'path' into the 'target' location in Grist. 'path' must be relative to the
                * root of the plugin's directory and point to an html that is contained within the plugin's
                * directory. 'target' is a predefined location of the Grist UI, it could be 'fullscreen' or
                * identifier for an inline target. Grist provides inline target identifiers in certain call
                * plugins. E.g. ImportSourceAPI.getImportSource is given a target identifier to allow rende UI
                * inline in the import dialog. Returns the procId which can be used to dispose the view.
                */
            render(path: string, target: RenderTarget, options?: RenderOptions): Promise<number>;
            /**
                * Dispose the process with id procId. If the process was embedded into the UI, removes the
                * corresponding element from the view.
                */
            dispose(procId: number): Promise<void>;
            subscribe(tableId: string): Promise<void>;
            unsubscribe(tableId: string): Promise<void>;
    }
    /**
        * Allows getting information from and interacting with the Grist document to which a plugin or widget is attached.
        */
    export interface GristDocAPI {
            /**
                * Returns an identifier for the document.
                */
            getDocName(): Promise<string>;
            /**
                * Returns a sorted list of table IDs.
                */
            listTables(): Promise<string[]>;
            /**
                * Returns a complete table of data as [[RowRecords]], including the
                * 'id' column. Do not modify the returned arrays in-place, especially if used
                * directly (not over RPC).
                */
            fetchTable(tableId: string): Promise<any>;
            /**
                * Applies an array of user actions.
                */
            applyUserActions(actions: any[][], options?: any): Promise<any>;
    }
    /**
        * Interface for the data backing a single widget.
        */
    export interface GristView {
            /**
                * Like [[GristDocAPI.fetchTable]], but gets data for the custom section specifically, if there is any.
                */
            fetchSelectedTable(): Promise<any>;
            /**
                * Fetches selected record by its 'rowId'.
                */
            fetchSelectedRecord(rowId: number): Promise<any>;
            /**
                * Allow custom widget to be listed as a possible source for linking with SELECT BY.
                */
            allowSelectBy(): Promise<void>;
            /**
                * Set the list of selected rows to be used against any linked widget. Requires 'allowSelectBy()'.
                */
            setSelectedRows(rowIds: number[]): Promise<void>;
    }
}

declare module 'grist/GristData' {
    export const enum GristObjCode {
            List = "L",
            LookUp = "l",
            Dict = "O",
            DateTime = "D",
            Date = "d",
            Skip = "S",
            Censored = "C",
            Reference = "R",
            ReferenceList = "r",
            Exception = "E",
            Pending = "P",
            Unmarshallable = "U",
            Versions = "V"
    }
    export type CellValue = number | string | boolean | null | [GristObjCode, ...unknown[]];
    export interface BulkColValues {
            [colId: string]: CellValue[];
    }
    /**
        * Map of column ids to 'CellValue's.
        *
        * ### CellValue
        *
        * Each 'CellValue' may either be a primitive (e.g. 'true', '123', '"hello"', 'null')
        * or a tuple (JavaScript Array) representing a Grist object. The first element of the tuple
        * is a string character representing the object code. For example, '["L", "foo", "bar"]'
        * is a 'CellValue' of a Choice List column, where '"L"' is the type, and '"foo"' and
        * '"bar"' are the choices.
        *
        * ### Grist Object Types
        *
        * | Code | Type           |
        * | ---- | -------------- |
        * | L    | List           |
        * | l    | LookUp         |
        * | O    | Dict           |
        * | D    | DateTime       |
        * | d    | Date           |
        * | C    | Censored       |
        * | R    | Reference      |
        * | r    | ReferenceList  |
        * | E    | Exception      |
        * | P    | Pending        |
        * | U    | Unmarshallable |
        * | V    | Version        |
        */
    export interface RowRecord {
            id: number;
            [colId: string]: CellValue;
    }
    /**
        * Map of column ids to 'CellValue' arrays, where array indexes correspond to
        * rows.
        *
        * ### CellValue
        *
        * Each 'CellValue' may either be a primitive (e.g. 'true', '123', '"hello"', 'null')
        * or a tuple (JavaScript Array) representing a Grist object. The first element of the tuple
        * is a string character representing the object code. For example, '["L", "foo", "bar"]'
        * is a 'CellValue' of a Choice List column, where '"L"' is the type, and '"foo"' and
        * '"bar"' are the choices.
        *
        * ### Grist Object Types
        *
        * | Code | Type           |
        * | ---- | -------------- |
        * | L    | List           |
        * | l    | LookUp         |
        * | O    | Dict           |
        * | D    | DateTime       |
        * | d    | Date           |
        * | C    | Censored       |
        * | R    | Reference      |
        * | r    | ReferenceList  |
        * | E    | Exception      |
        * | P    | Pending        |
        * | U    | Unmarshallable |
        * | V    | Version        |
        */
    export interface RowRecords {
            id: number[];
            [colId: string]: CellValue[];
    }
    export type GristType = 'Any' | 'Attachments' | 'Blob' | 'Bool' | 'Choice' | 'ChoiceList' | 'Date' | 'DateTime' | 'Id' | 'Int' | 'ManualSortPos' | 'Numeric' | 'PositionNumber' | 'Ref' | 'RefList' | 'Text';
}

declare module 'grist/RenderOptions' {
    /**
        * Where to append the content that a plugin renders.
        *
        * @internal
        */
    export type RenderTarget = "fullscreen" | number;
    /**
        * Options for the 'grist.render' function.
        */
    export interface RenderOptions {
            height?: string;
    }
}

declare module 'grist/TableOperations' {
    import * as Types from 'app/plugin/DocApiTypes';
    /**
        * Offer CRUD-style operations on a table.
        */
    export interface TableOperations {
            /**
                * Create a record or records.
                */
            create(records: Types.NewRecord, options?: OpOptions): Promise<Types.MinimalRecord>;
            create(records: Types.NewRecord[], options?: OpOptions): Promise<Types.MinimalRecord[]>;
            /**
                * Update a record or records.
                */
            update(records: Types.Record | Types.Record[], options?: OpOptions): Promise<void>;
            /**
                * Delete a record or records.
                */
            destroy(recordIds: Types.RecordId | Types.RecordId[]): Promise<void>;
            /**
                * Add or update a record or records.
                */
            upsert(records: Types.AddOrUpdateRecord | Types.AddOrUpdateRecord[], options?: UpsertOptions): Promise<void>;
            /**
                * Determine the tableId of the table.
                */
            getTableId(): Promise<string>;
    }
    /**
        * General options for table operations.
        */
    export interface OpOptions {
            /** Whether to parse strings based on the column type. Defaults to true. */
            parseStrings?: boolean;
    }
    /**
        * Extra options for upserts.
        */
    export interface UpsertOptions extends OpOptions {
            /** Permit inserting a record. Defaults to true. */
            add?: boolean;
            /** Permit updating a record. Defaults to true. */
            update?: boolean;
            /** Whether to update none, one, or all matching records. Defaults to "first". */
            onMany?: 'none' | 'first' | 'all';
            /** Allow "wildcard" operation. Defaults to false. */
            allowEmptyRequire?: boolean;
    }
}

declare module 'grist/WidgetAPI' {
    /**
        * API to manage Custom Widget state.
        */
    export interface WidgetAPI {
            /**
                * Gets all options stored by the widget. Options are stored as plain JSON object.
                */
            getOptions(): Promise<object | null>;
            /**
                * Replaces all options stored by the widget.
                */
            setOptions(options: {
                    [key: string]: any;
            }): Promise<void>;
            /**
                * Clears all the options.
                */
            clearOptions(): Promise<void>;
            /**
                * Store single value in the Widget options object (and create it if necessary).
                */
            setOption(key: string, value: any): Promise<void>;
            /**
                * Get single value from Widget options object.
                */
            getOption(key: string): Promise<any>;
    }
}

declare module 'grist/TypeCheckers' {
    import { ICheckerSuite } from 'ts-interface-checker';
    import CustomSectionAPITI from 'grist/CustomSectionAPI-ti';
    import FileParserAPITI from 'grist/FileParserAPI-ti';
    import GristAPITI from 'grist/GristAPI-ti';
    import GristTableTI from 'grist/GristTable-ti';
    import ImportSourceAPITI from 'grist/ImportSourceAPI-ti';
    import InternalImportSourceAPITI from 'grist/InternalImportSourceAPI-ti';
    import RenderOptionsTI from 'grist/RenderOptions-ti';
    import StorageAPITI from 'grist/StorageAPI-ti';
    import WidgetAPITI from 'grist/WidgetAPI-ti';
    /**
        * The ts-interface-checker type suites are all exported with the "TI" suffix.
        */
    export { CustomSectionAPITI, FileParserAPITI, GristAPITI, GristTableTI, ImportSourceAPITI, InternalImportSourceAPITI, RenderOptionsTI, StorageAPITI, WidgetAPITI };
    /**
        * We also create and export a global checker object that includes all of the types above.
        */
    export const checkers: Pick<ICheckerSuite, "ParseOptions" | "ParseFileResult" | "FileSource" | "ParseOptionSchema" | "GristTables" | "RenderTarget" | "RenderOptions" | "GristColumn" | "GristTable" | "ImportSource" | "FileContent" | "FileListItem" | "URL" | "CustomSectionAPI" | "EditOptionsAPI" | "ParseFileAPI" | "ComponentKind" | "GristAPI" | "GristDocAPI" | "GristView" | "ImportSourceAPI" | "ImportProcessorAPI" | "InternalImportSourceAPI" | "Storage" | "WidgetAPI">;
}

declare module 'grist/FileParserAPI' {
    /**
        * API definitions for FileParser plugins.
        */
    import { GristTables } from 'grist/GristTable';
    export interface EditOptionsAPI {
            getParseOptions(parseOptions?: ParseOptions): Promise<ParseOptions>;
    }
    export interface ParseFileAPI {
            parseFile(file: FileSource, parseOptions?: ParseOptions): Promise<ParseFileResult>;
    }
    /**
        * ParseOptions contains parse options depending on plugin,
        * number of rows, which is special option that can be used for any plugin
        * and schema for generating parse options UI
        */
    export interface ParseOptions {
            NUM_ROWS?: number;
            SCHEMA?: ParseOptionSchema[];
    }
    /**
        * ParseOptionSchema contains information for generaing parse options UI
        */
    export interface ParseOptionSchema {
            name: string;
            label: string;
            type: string;
            visible: boolean;
    }
    export interface FileSource {
            /**
                * The path is often a temporary file, so its name is meaningless. Access to the file depends on
                * the type of plugin. For instance, for 'safePython' plugins file is directly available at
                * '/importDir/path'.
                */
            path: string;
            /**
                * Plugins that want to know the original filename should use origName. Depending on the source
                * of the data, it may or may not be meaningful.
                */
            origName: string;
    }
    export interface ParseFileResult extends GristTables {
            parseOptions: ParseOptions;
    }
}

declare module 'grist/GristTable' {
    /**
        * Metadata and data for a table.
        */
    export interface GristTable {
            table_name: string | null;
            column_metadata: GristColumn[];
            table_data: any[][];
    }
    export interface GristTables {
            tables: GristTable[];
    }
    /**
        * Metadata about a single column.
        */
    export interface GristColumn {
            id: string;
            type: string;
    }
    export enum APIType {
            ImportSourceAPI = 0,
            ImportProcessorAPI = 1,
            ParseOptionsAPI = 2,
            ParseFileAPI = 3
    }
}

declare module 'grist/ImportSourceAPI' {
    /**
        * API definitions for ImportSource plugins.
        */
    import { GristTable } from 'grist/GristTable';
    export interface ImportSourceAPI {
            /**
                * Returns a promise that resolves to an 'ImportSource' which is then passed for import to the
                * import modal dialog. 'undefined' interrupts the workflow and prevent the modal from showing up,
                * but not an empty list of 'ImportSourceItem'. Which is a valid import source and is used in
                * cases where only options are to be sent to an 'ImportProcessAPI' implementation.
                */
            getImportSource(): Promise<ImportSource | undefined>;
    }
    export interface ImportProcessorAPI {
            processImport(source: ImportSource): Promise<GristTable[]>;
    }
    export interface FileContent {
            content: any;
            name: string;
    }
    export interface FileListItem {
            kind: "fileList";
            files: FileContent[];
    }
    export interface URL {
            kind: "url";
            url: string;
    }
    export interface ImportSource {
            item: FileListItem | URL;
            /**
                * The options are only passed within this plugin, nothing else needs to know how they are
                * serialized. Using JSON.stringify/JSON.parse is a simple approach.
                */
            options?: string | Buffer;
            /**
                * The short description that shows in the import dialog after source have been selected.
                */
            description?: string;
    }
}

declare module 'grist/StorageAPI' {
    export interface Storage {
        getItem(key: string): any;
        hasItem(key: string): boolean;
        setItem(key: string, value: any): void;
        removeItem(key: string): void;
        clear(): void;
    }
}

declare module 'grist/CustomSectionAPI-ti' {
    /**
      * This module was automatically generated by 'ts-interface-builder'
      */
    import * as t from "ts-interface-checker";
    export const ColumnToMap: t.TIface;
    export const ColumnsToMap: t.TArray;
    export const InteractionOptionsRequest: t.TIface;
    export const InteractionOptions: t.TIface;
    export const WidgetColumnMap: t.TIface;
    export const CustomSectionAPI: t.TIface;
    const exportedTypeSuite: t.ITypeSuite;
    export default exportedTypeSuite;
}

declare module 'grist/FileParserAPI-ti' {
    /**
      * This module was automatically generated by 'ts-interface-builder'
      */
    import * as t from "ts-interface-checker";
    export const EditOptionsAPI: t.TIface;
    export const ParseFileAPI: t.TIface;
    export const ParseOptions: t.TIface;
    export const ParseOptionSchema: t.TIface;
    export const FileSource: t.TIface;
    export const ParseFileResult: t.TIface;
    const exportedTypeSuite: t.ITypeSuite;
    export default exportedTypeSuite;
}

declare module 'grist/GristAPI-ti' {
    /**
      * This module was automatically generated by 'ts-interface-builder'
      */
    import * as t from "ts-interface-checker";
    export const ComponentKind: t.TUnion;
    export const GristAPI: t.TIface;
    export const GristDocAPI: t.TIface;
    export const GristView: t.TIface;
    const exportedTypeSuite: t.ITypeSuite;
    export default exportedTypeSuite;
}

declare module 'grist/GristTable-ti' {
    /**
      * This module was automatically generated by 'ts-interface-builder'
      */
    import * as t from "ts-interface-checker";
    export const GristTable: t.TIface;
    export const GristTables: t.TIface;
    export const GristColumn: t.TIface;
    export const APIType: t.TEnumType;
    const exportedTypeSuite: t.ITypeSuite;
    export default exportedTypeSuite;
}

declare module 'grist/ImportSourceAPI-ti' {
    /**
      * This module was automatically generated by 'ts-interface-builder'
      */
    import * as t from "ts-interface-checker";
    export const ImportSourceAPI: t.TIface;
    export const ImportProcessorAPI: t.TIface;
    export const FileContent: t.TIface;
    export const FileListItem: t.TIface;
    export const URL: t.TIface;
    export const ImportSource: t.TIface;
    const exportedTypeSuite: t.ITypeSuite;
    export default exportedTypeSuite;
}

declare module 'grist/InternalImportSourceAPI-ti' {
    /**
      * This module was automatically generated by 'ts-interface-builder'
      */
    import * as t from "ts-interface-checker";
    export const InternalImportSourceAPI: t.TIface;
    const exportedTypeSuite: t.ITypeSuite;
    export default exportedTypeSuite;
}

declare module 'grist/RenderOptions-ti' {
    /**
      * This module was automatically generated by 'ts-interface-builder'
      */
    import * as t from "ts-interface-checker";
    export const RenderTarget: t.TUnion;
    export const RenderOptions: t.TIface;
    const exportedTypeSuite: t.ITypeSuite;
    export default exportedTypeSuite;
}

declare module 'grist/StorageAPI-ti' {
    /**
      * This module was automatically generated by 'ts-interface-builder'
      */
    import * as t from "ts-interface-checker";
    export const Storage: t.TIface;
    const exportedTypeSuite: t.ITypeSuite;
    export default exportedTypeSuite;
}

declare module 'grist/WidgetAPI-ti' {
    /**
      * This module was automatically generated by 'ts-interface-builder'
      */
    import * as t from "ts-interface-checker";
    export const WidgetAPI: t.TIface;
    const exportedTypeSuite: t.ITypeSuite;
    export default exportedTypeSuite;
}


// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../../../../../grist-widget/inspect/events
//   ../../../../../grist-widget/inspect/ts-interface-checker

declare module 'grain-rpc' {
    export * from 'grain-rpc/message';
    export * from 'grain-rpc/rpc';
}

declare module 'grain-rpc/message' {
    /**
      * This defines the message types sent over an RpcChannel.
      *
      * WARNING: Any changes to these must be backward-compatible, since Rpc may be used across
      * different versions of this library. Specifically, enums must not be renumbered, fields renamed,
      * or their types changed. Really, the only reasonable enhancement is adding a new optional field.
      */
    export enum MsgType {
        RpcCall = 1,
        RpcRespData = 2,
        RpcRespErr = 3,
        Custom = 4,
        Ready = 5,
    }
    export interface IMsgRpcCall {
        mtype: MsgType.RpcCall;
        mdest?: string;
        reqId?: number;
        iface: string;
        meth: string;
        args: any[];
    }
    export interface IMsgRpcRespData {
        mtype: MsgType.RpcRespData;
        reqId: number;
        data?: any;
    }
    export interface IMsgRpcRespErr {
        mtype: MsgType.RpcRespErr;
        reqId: number;
        mesg: string;
        code?: string;
    }
    export interface IMsgCustom {
        mtype: MsgType.Custom;
        mdest?: string;
        data: any;
    }
    export interface IMsgReady {
        mtype: MsgType.Ready;
    }
    export type IMsgRpc = IMsgRpcCall | IMsgRpcRespData | IMsgRpcRespErr;
    export type IMessage = IMsgRpc | IMsgCustom | IMsgReady;
}

declare module 'grain-rpc/rpc' {
    /**
        * Rpc implements an remote-procedure-call interface on top of a simple messaging interface.
        *
        * The user must provide the messaging between two endpoints, and in return gets the ability to
        * register interfaces or functions at either endpoint, and call them from the other side. For
        * messaging, the user must supply a sendMessage() function to send messages to the other side,
        * and must call rpc.receiveMessage(msg) whenever a message is received.
        *
        * E.g.
        *    rpc.registerImpl<MyInterface>("some-name", new MyInterfaceImpl(), descMyInterfaceImpl);
        *    rpc.getStub<MyInterface>("some-name", descMyInterfaceImpl)
        *          => returns a stub implemeting MyInterface
        *
        * Calls to the generated stub get turned into messages across the channel, and then call to the
        * implementation object registered on the other side. Both return values and exceptions get
        * passed back over the channel, and cause the promise from the stub to be resolved or rejected.
        *
        * Note that the stub interface returns Promises for all methods.
        *
        * Rpc library supports ts-interface-checker descriptors for the interfaces, to allow validation.
        * You may skip it by passing in 'rpc.unchecked' where a descriptor is expected; it will skip
        * checks and you will not get descriptive errors.
        *
        * The string name used to register and use an implementation allows for the same Rpc object to be
        * used to expose multiple interfaces, or different implementations of the same interface.
        *
        * Messaging
        * ---------
        * Rpc also supports a messaging interface, with postMessage() to send arbitrary messages, and an
        * EventEmitter interface for "message" events to receive them, e.g. on("message", ...). So if you
        * need to multiplex non-Rpc messages over the same channel, Rpc class does it for you.
        *
        * Cleanup
        * -------
        * If the channel is closed or had an error, and will no longer be used, the user of Rpc must
        * call rpc.close() to reject any calls waiting for an answer.
        *
        * If a particular stub for a remote API is no longer needed, user may call rpc.discardStub(stub)
        * to reject any pending calls made to that stub.
        *
        * Timeouts
        * --------
        * TODO (Not yet implementd.)
        * You may call rpc.setTimeout(ms) or rpc.setStubTimeout(stub, ms) to set a call timeout for all
        * stubs or for a particular one. If a response to a call does not arrive within the timeout, the
        * call gets rejected, and the rejection Error will have a "code" property set to "TIMEOUT".
        *
        * Forwarding
        * ----------
        * Rpc.registerForwarder() along with methods with "-Forward" suffix allow one Rpc object to forward
        * calls and messages to another Rpc object. The intended usage is when Rpc connects A to B, and B
        * to C. Then B can use registerForwarder to expose A's interfaces to C (or C's to A) without having
        * to know what exactly they are. A default forwarder can be registered using the '*' name.
        *
        *
        * Instead of using getStubForward and callRemoteFuncForward, the forwarder name can be
        * appended to the interface name as "interfaceName@forwarderName" and the regular
        * getStub and callRemoteFunc methods can be used.  For example:
        *   getStub("iface@forwarder")
        * is the same as:
        *   getStubForward("forwarder", "iface")
        *
        *
        * E.g. with A.registerImpl("A-name", ...) and B.registerForwarder("b2a", A), we may now call
        * C.getStubForward("b2a", "A-name") to get a stub that will forward calls to A, as well as
        * C.postMessageForward("b2a", msg) to have the message received by A.
        *
        * TODO We may want to support progress callbacks, perhaps by supporting arbitrary callbacks as
        * parameters. (Could be implemented by allowing "meth" to be [reqId, paramPath]) It would be nice
        * to allow the channel to report progress too, e.g. to report progress of uploading large files.
        *
        * TODO Sending of large files should probably be a separate feature, to allow for channel
        * implementations to stream them.
        */
    import { EventEmitter } from "events";
    import * as tic from "ts-interface-checker";
    import { IMessage, IMsgCustom, IMsgRpcCall } from "grain-rpc/message";
    export type SendMessageCB = (msg: IMessage) => Promise<void> | void;
    export interface IForwarderDest {
            forwardCall: (c: IMsgRpcCall) => Promise<any>;
            forwardMessage: (msg: IMsgCustom) => Promise<any>;
    }
    export type ICallWrapper = (callFunc: () => Promise<any>) => Promise<any>;
    export class Rpc extends EventEmitter implements IForwarderDest {
            /**
                * To use Rpc, you must provide a sendMessage function that sends a message to the other side;
                * it may be given in the constructor, or later with setSendMessage. You must also call
                * receiveMessage() for every message received from the other side.
                */
            constructor(options?: {
                    logger?: IRpcLogger;
                    sendMessage?: SendMessageCB;
                    callWrapper?: ICallWrapper;
            });
            /**
                * To use Rpc, call this for every message received from the other side of the channel.
                */
            receiveMessage(msg: IMessage): void;
            /**
                * If you've set up calls to receiveMessage(), but need time to call registerImpl() before
                * processing new messages, you may use queueIncoming(), make the registerImpl() calls,
                * and then call processIncoming() to handle queued messages and resume normal processing.
                */
            queueIncoming(): void;
            /**
                * Process received messages queued since queueIncoming, and resume normal processing of
                * received messages.
                */
            processIncoming(): void;
            /**
                * Set the callback to send messages. If set to null, sent messages will be queued. If you
                * disconnect and want for sent messages to throw, set a callback that throws.
                */
            setSendMessage(sendMessage: SendMessageCB | null): void;
            /**
                * If your peer may not be listening yet to your messages, you may call this to queue outgoing
                * messages until receiving a "ready" message from the peer. I.e. one peer may call
                * queueOutgoingUntilReadyMessage() while the other calls sendReadyMessage().
                */
            queueOutgoingUntilReadyMessage(): void;
            /**
                * If your peer is using queueOutgoingUntilReadyMessage(), you should let it know that you are
                * ready using sendReadyMessage() as soon as you've set up the processing of received messages.
                * Note that at most one peer may use queueOutgoingUntilReadyMessage(), or they will deadlock.
                */
            sendReadyMessage(): void | Promise<void>;
            /**
                * Messaging interface: send data to the other side, to be emitted there as a "message" event.
                */
            postMessage(data: any): Promise<void>;
            postMessageForward(fwdDest: string, data: any): Promise<void>;
            /**
                * Registers a new implementation under the given name. It is an error if this name is already
                * in use. To skip all validation, use 'registerImpl<any>(...)' and omit the last argument.
                * TODO Check that registerImpl without a type param requires a checker.
                */
            registerImpl<Iface extends any>(name: string, impl: any): void;
            registerImpl<Iface>(name: string, impl: Iface, checker: tic.Checker): void;
            registerForwarder(fwdName: string, dest: IForwarderDest, fwdDest?: string): void;
            unregisterForwarder(fwdName: string): void;
            /**
                * Unregister an implementation, if one was registered with this name.
                */
            unregisterImpl(name: string): void;
            /**
                * Creates a local stub for the given remote interface. The stub implements Iface, forwarding
                * calls to the remote implementation, each one returning a Promise for the received result.
                * To skip all validation, use 'any' for the type and omit the last argument.
                *
                * Interface names can be followed by a "@<forwarder>" part
                */
            getStub<Iface extends any>(name: string): Iface;
            getStub<Iface>(name: string, checker: tic.Checker): Iface;
            getStubForward<Iface extends any>(fwdDest: string, name: string): any;
            getStubForward<Iface>(fwdDest: string, name: string, checker: tic.Checker): Iface;
            /**
                * Simple way to registers a function under a given name, with no argument checking.
                */
            registerFunc(name: string, impl: (...args: any[]) => any): void;
            /**
                * Unregister a function, if one was registered with this name.
                */
            unregisterFunc(name: string): void;
            /**
                * Call a remote function registered with registerFunc. Does no type checking.
                */
            callRemoteFunc(name: string, ...args: any[]): Promise<any>;
            callRemoteFuncForward(fwdDest: string, name: string, ...args: any[]): Promise<any>;
            forwardCall(c: IMsgRpcCall): Promise<any>;
            forwardMessage(msg: IMsgCustom): Promise<any>;
    }
    /**
        * Interfaces may throw errors that include .code field, and it gets propagated to callers (e.g.
        * "NOT_AUTHORIZED"). Its purpose is to be a stable way to distinguish different types of errors.
        * This way the human-friendly error message can be changed without affecting behavior.
        */
    export class ErrorWithCode extends Error {
            code: string | undefined;
            constructor(code: string | undefined, message: string);
    }
    /**
        * Rpc logs everything to the passed-in logger, which is by default the console, but you may
        * provide your own.
        */
    export interface IRpcLogger {
            info?(message: string): void;
            warn?(message: string): void;
    }
}


`;